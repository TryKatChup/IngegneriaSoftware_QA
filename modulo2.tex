\newpage
\section{Modulo 2}
\begin{problem}{2.1}
Spiegare il modello a cascata e le sue criticità.
\end{problem}
\begin{solution}
Il modello a cascata (waterfall model) è un modello di processo di sviluppo software che prevede fasi sequenziali distinte tra loro:
\begin{itemize}
	\item studio di fattibilità;
	\item analisi dei requisiti;
	\item analisi del problema;
	\item progettazione;
	\item implementazione;
	\item collaudo;
	\item manutenzione.
\end{itemize}
Ciascuna fase di sviluppo deve essere svolta in maniera esaustiva, prima di passare alla successiva, in modo da non tornare più indietro.
Per questo modello è importante definire:
\begin{itemize}
	\item \textbf{Semilavorati}: consistono in documentazione di tipo cartaceo, codice dei singoli moduli, sistema nel suo complesso.\newline
	Vengono prodotti da una fase, e utilizzati dalla fase successiva; in questo modo viene garantito un controllo della qualità del lavoro eseguito in ogni fase.
	\item \textbf{Date}: stabiliscono una scadenza entro la quale devono essere prodotti i semilavorati, in modo da tracciare il progresso del lavoro (workflow).
\end{itemize}
L'efficacia del modello a cascata è determinata dai seguenti fattori:
\begin{itemize}
	\item \textbf{Immutabilità dell'analisi}: i clienti sono in grado di esprimere tutte le loro richieste sin da subito, pertanto nella fase iniziale del progetto si possono definire tutte le funzionalità che il software deve eseguire.
	\item \textbf{Immutabilità del progetto}: progettare l'intero sistema prima di avere scritto codice risulta possibile.
\end{itemize}
Un importante vantaggio di questo approccio risulta essere un maggiore controllo dell'andamento del progetto; tuttavia la rigidità di questo modello rappresenta un grosso svantaggio, in quanto:
\begin{itemize}
	\item man mano che il sistema prende forma le sue specifiche cambiano in continuazione, così come la visione che i clienti hanno del sistema;
	\item spesso, per avere prestazioni migliori, occorre revisionare il progetto.
\end{itemize}
Per risolvere parzialmente i problemi sopra citati si è introdotto un modello a cascata con forme limitate di retroazione a un livello.
Una possibile soluzione al problema consiste nel realizzare un prototipo che, una volta terminato il compito, viene abbandonato (\textit{throw-away prototyping}); successivamente viene costruito il sistema reale rispettando il modello a cascata.
\newline
Tuttavia quest'ultimo approccio risulta talmente dispensioso da eliminare i vantaggi economici del modello a cascata.
\end{solution}


\begin{problem}{2.2}
Spiegare il modello a cascata e il modello iterativo
\end{problem}
\begin{solution}
Per il modello a cascata si veda la domanda 2.1.
\newline
Il modello iterativo prevede un numero elevato di passi nel ciclo di sviluppo che iteramente aumentano il livello di dettaglio del sistema.
Uno svantaggio di questo modello è che non può essere utilizzato nella realizzazione dei progetti significativi.
Un esempio di processo di sviluppo che utilizza il modello iterativo è \textit{Rational Unified Process} (RUP).
\end{solution}


\begin{problem}{2.3}
Illustrare RUP
\end{problem}
\begin{solution}
Il \textit{Rational Unified Process} (RUP) rappresenta un modello di processo software \textbf{iterativo} (si veda domanda 2.2) e \textbf{ibrido} (contiene elementi di tutti i modelli di processo generici) pensato per software di grandi dimensioni.
\newline
Esistono tre aspetti importanti del processo di sviluppo:
\begin{itemize}
	\item \textbf{Prospettiva dinamica}: mostra l'evoluzione del modello nel tempo. È composta da 4 fasi:
	\begin{enumerate}
		\item \textbf{Avvio}: lo scopo di questa fase è di delineare il \textit{business case}, ovvero comprendere il tipo di mercato a cui si rivolge, le entità esterne (persone e sistemi) che interagiscono con il sistema.
		\newline
		Durante la fase di avvio si utilizzano modelli di caso d'uso e si effettua una valutazione dei rischi.
		\item \textbf{Elaborazione}: questa fase definisce la struttura complessiva del sistema; comprende l'analisi del dominio e una prima fase di progettazione dell'architettura.
		\newline
		Occorre soddisfase alcuni criteri, tra i quali:
		\begin{itemize}
			\item modello dei casi d'uso completo all' 80\%;
			\item descrizione dell'architettura del sistema;
			\item sviluppo dell'architettura del sistema;
			\item sviluppo di un'architettura eseguibile adatta agli use case significativi;
			\item revisione dei business case e dei rischi;
			\item pianificazione del progetto complessivo.
		\end{itemize}
		\textbf{Nota bene:} al termine di questa fase modificare il progetto risulterà più difficile e dannoso.
		\item \textbf{Costruzione}: durante questa fase avviene la progettazione, la programmazione e il collaudo del sistema.
		Lo sviluppo delle diverse parti del sistema avviene in parallelo; successivamente vengono integrate.
		\newline
		Al termine di questa fase il sistema software dovrebbe essere funzionante e la relativa documentazione dovrebbe risultare pronta.
		\item \textbf{Transizione}: il sistema passa dall'ambiente di sviluppo a quello dell'utente finale. Quest'ultimo viene istruito nell'utilizzo del sistema, e si effettua \textit{beta testing} del sistema a scopo di verifica e validazione.
	\end{enumerate}
	\item \textbf{Prospettiva statica}: si focalizza sulle attività di produzione del software, note come \textit{workflow}; la descrizione di questi ultimi è orientata ai modelli associati a UML.
	Esistono sei workflow principali:
	\begin{enumerate}
		\item \textbf{Modellazione delle attività aziendali}: i processi aziendali vengono modellati, sfruttando il \textit{business case}.
		\item \textbf{Requisiti}: vengono sviluppati i casi d'uso per la stesura dei requisiti; avviene l'identificazione degli attori che interagiscono con il sistema.
		\item \textbf{Analisi e progetto}: attraverso l'utilizzo dei modelli architetturali e sequenziali degli oggetti e delle componenti viene creato e documentato un \textit{modello di progetto}.
		\item \textbf{Implementazione}: i componenti vengono implementati; grazie alla generazione automatica del codice a partire dai modelli precedentemente definiti.
		\item \textbf{Test}: vengono testati i sottocomponenti e il sistema finale.
		\item \textbf{Rilascio}: il prodotto viene distribuito agli utenti.
	\end{enumerate}
	Oltre ai 6 workflow principali vengono definiti 3 workflow di supporto:
	\begin{enumerate}
		\item \textbf{Gestione della configurazione e delle modifiche}: gestisce i cambiamenti del sistema.
		\item \textbf{Gestione del progetto}: gestisce lo sviluppo del sistema.
		\item \textbf{Ambiente}: fornisce agli sviluppatori degli strumenti adeguati.
	\end{enumerate}
	\item \textbf{Prospettiva pratica}: suggerisce le \textit{buone prassi} da seguire nello sviluppo dei sistemi.
	\newline
	Esistono sei fasi fondamentali:
	\begin{enumerate}
		\item \textbf{Sviluppare ciclicamente il software}: pianificare e consegnare le funzioni aventi la priorità più alta.
		\item \textbf{Gestire i requisiti}: documentare ogni richiesta esplicita del cliente e ogni cambiamento effettuato, analizzandone l'impatto.
		\item \textbf{Usare architetture basate sui componenti}: strutturare l'architettura del sistema in più componenti.
		\item \textbf{Usare modelli visivi del software}: utilizzare grafici UML per la rappresentazione statica e dinamica del software.
		\item \textbf{Verificare la qualità del software}: assicurarsi che vengano raggiunti gli standard di qualità previsti dall'organizzazione.
		\item \textbf{Controllare le modifiche del software}: utilizzare strumenti e pratiche che permettono di gestire modifiche al software.
	\end{enumerate}
\end{itemize}

\end{solution}

\begin{problem}{2.4}
Tipologie di requisiti
\end{problem}
\begin{solution}
I requisiti rappresentano la descrizione dei servizi che vengono forniti dal sistema e dei suoi vincoli.
\newline
Esistono due tipologie di requisiti:
\begin{itemize}
	\item \textit{Requisiti utente}: specificano i servizi offerti dal sistema e i vincoli su cui opera. Risultano molto astratti e di alto livello, e sono espressi solitamente in linguaggio naturale assieme a diagrammi.
	\item \textit{Requisiti di sistema}: specificano nel \textit{documento dei requisiti del sistema} le funzioni, i servizi e i vincoli del sistema in modo dettagliato.
	\newline
	Questi ultimi sono ulteriormente diviso in tre categorie:
	\begin{itemize}
		\item \textbf{Requisiti funzionali}: elenca i servizi che il sistema deve fornire, in particolare per ciascun servizio viene specificato come reagire a particolari input, come comportarsi in specifiche situazioni, e cosa il sistema non dovrebbe fare.
		\item \textbf{Requisiti non funzionali}: descrivono altre caratteristiche del sistema, tra le quali:
		\begin{itemize}
			\item \textit{Requisiti del prodotto}: limitano le proprietà del sistema.
			\item \textit{Requisiti organizzativi}: vincolano il processo di sviluppo.
			\item \textit{Requisiti esterni}: sono vincoli che derivano da sistemi esterni o da contesti come la legislazione sulla privacy o requisiti etici.
		\end{itemize}
		Altre caratteristiche che riguardano i requisiti non funzionali è la difficoltà di verifica di questi ultimi, poiché risultano poco chiari e vaghi.
		Spesso risultano in contraddizione con i requisiti funzionali: un esempio è la protezione della privacy che può essere in contrasto con la facilità d'uso o con i tempi di risposta di un sistema.
		\item \textbf{Requisiti del dominio}: derivano dal dominio di applicazione del sistema e indicano il funzionamento del sistema all'interno di uno specifico dominio.
		\newline
		Il dominio di applicazione del sistema viene specificato agli esperti del dominio.
	\end{itemize}
\end{itemize}
\end{solution}

\begin{problem}{2.5}
Si illustri brevemente il ciclo di vita della valutazione del rischio
\end{problem}
\begin{solution}
L'analisi del rischio si occupa di bilanciare eventuali perdite, dovute ad attacchi informatici, con i costi richiesti per assicurare la protezione dei beni.
\newline
Un'importante componente dell'analisi del rischio è la valutazione del rischio, composta da pù fasi:
\begin{itemize}
	\item \textbf{Valutazione preliminare del rischio}: determina i requisiti di sicurezza dell'intero sistema.
	\item \textbf{Ciclo di vita della valutazione del rischio}: avviene parallelamente al ciclo di vita dello sviluppo del software.
	\newline
	In questa fase occorre conoscere l'architettura del sistema e l'organizzazione dei dati.
	\newline
	La scelta della piattaforma e del middleware è stata già effettuata, così come la strategia di sviluppo del sistema; ciò consente di conoscere meglio cosa è necessario proteggere e quali sono le possibili vulnerabilità del sistema, alcune delle quali determinate da scelte progettuali precedenti.
	\newline
	In questa fase vengono effettuate l'\textit{identificazione} e la \textit{valutazione} della vulnerabilità, ovvero quali beni hanno la maggiore probabilità di essere colpiti.
	\newline
	Il risultato della valutazione del rischio è un insieme di decisioni ingegneristiche che influenzano la progettazione o l'implementazione del sistema e limitano il suo utilizzo.
\end{itemize}
\end{solution}

\begin{problem}{2.6}
Principali categorie di requisiti per la sicurezza
\end{problem}
\begin{solution}
Lo scopo dei requisiti di sicurezza è di definire quali comportamenti risultano inaccettabili per il sistema, senza definire le funzionalità richieste al sistema.
I requisiti di sicurezza specificano il contesto, i beni da proteggere e il valore che questi ultimi hanno per l'organizzazione.
\newline
Le categorie dei requisiti per la sicurezza sono:
\begin{itemize}
	\item \textbf{Requisiti di identificazione}: specificano se un sistema deve eseguire l'identificazione dei clienti, prima di una qualsiasi interazione con loro.
	\item \textbf{Requisiti di autenticazione}: specificano le modalità di autenticazione degli utenti.
	\item \textbf{Requisiti di autorizzazione}: specificano i permessi e i privilegi che gli utenti possiedono una volta identificati.
	\item \textbf{Requisiti di immunità}: specificano i meccanismi di difesa che il sistema deve adottare per difendersi da eventuali malware.
	\item \textbf{Requisiti di integrità}: specificano come evitare le corruzioni dei dati.
	\item \textbf{Requisiti di scoperta delle intrusioni}: specificano quali meccanismi vengono adottati per la rilevazione degli attacchi.
	\item \textbf{Requisiti di non-ripudiazione}: specificano che una parte interessata in una transazione non può negare il proprio coinvolgimento.
	\item \textbf{Requisiti di riservatezza}: specificano come deve essere mantenuta la riservatezza delle informazioni.
	\item \textbf{Requisiti di controllo della protezione}: specificano come deve essere controllato e verificato l'utilizzo del sistema.
	\item \textbf{Requisiti di protezione della manutenzione del sistema}: specificano come un' applicazione può evitare modifiche autorizzate, nel caso in cui accidentalmente vengano annullati i meccanismi di protezione.
\end{itemize}
\end{solution}


\begin{problem}{2.7}
Linee guida di progettazione nella sicurezza
\end{problem}
\begin{solution}
Le linee guida per la sicurezza nella progettazione sono le seguenti:
\begin{enumerate}
	\item Basarsi su una politica esplicita per le decisioni inerenti la sicurezza.
	\newline
	Le politiche di sicurezza vengono esplicitate in documenti di alto livello, che definiscono quali siano i criteri della sicurezza, ma non specificano come ottenerla.
	Occoore incorporare politiche di sicurezza in modo da specificare quali sono le informazioni che possono essere accedute e quale ente può accedervi, e quali precondizioni occorre soddisfare per l'accesso.
	\item Evitare ogni singolo punto di fallimento, poiché il fallimento di una parte del sistema può compromettere l'intero sistema.
	\item Fallire in modo controllato.
	\item Bilanciare sicurezza e usabilità del sistema, dato che l'aggiunta di ulteriori livelli di sicurezza possono richiedere tempo maggiore di apprendimento dell'uso del sistema da parte dell'utente.
	\item Essere consapevoli delle conseguenze che l'ingegneria sociale può portare, poiché tramite quest'ultima è semplice ottenere alcuni dati personali dell'utente, e convincerlo a rivelare ulteriori dati sensibili.
	\item Utilizzare per ridurre rischi i seguenti fattori:
	\begin{itemize}
		\item \textbf{Ridondanza}: mantenimento di più versioni dello stesso software e di dati nel sistema.
		\item \textbf{Diversità}: consiste nell'utilizzo di tecnologie diverse per le varie versioni del sistema, in modo che una vulnerabilità di una tecnologia non consenta un punto di fallimento comune.
	\end{itemize}
	\item Validare l'input, ovvero applicare controlli ai dati di ingresso, in modo da non potere sfruttare vulnerabilità come \textit{SQL Injection}, \textit{Buffer Overflow}, etc.
	\item Organizzare le informazioni di sistema in compartimenti, in modo che gli utenti possano accedere alle informazioni di loro competenza.
	\item Progettare per il \textit{deployment}, includendo nel sistema programmi di utilità che semplifichino il processo di \textit{deployment}.
	\newline
	Alcune indicazioni sono elencate in seguito:
	\begin{itemize}
		\item includere supporto per la visione e analisi delle configurazioni;
		\item ridurre al minimo i privilegi di default;
		\item rendere le impostazioni di configurazione locali;
		\item fornire metodi per rimediare a vulnerabilità.
	\end{itemize}
	\item Progettare per il ripristino, includendo meccanismi diretti o automatici per aggiornare il sistema e risolvere le vulnerabilità scoperte.
\end{enumerate}
\end{solution}

\begin{problem}{2.8}
White box e black box testing
\end{problem}
\begin{solution}
Il \textit{Black box testing} consente di trovare le vulnerabilità di un sistema, senza sapere come esso è stato implementato.
Gli aspetti che vengono migliorati principalmente sono la velocità del sistema, l'affidabilità, la velocità.
I tester non possiedono il codice sorgente, ma cercano di intuire la struttura del sistema, per poi attaccarlo in modo mirato.
\newline
Sfruttano molte vulnerabilità inerenti ai linguaggi di programmazione utilizzati, alle configurazioni delle reti, degli host e delle maccchine virtuali.
\newline
Il \textit{White box testing} prevede la conoscenza completa dell'applicazione da parte dei tester, dalle informazioni di configurazione delle reti e delle macchine virtuali fino al codice sorgente.
In questo modo i tester possono effettuare una revisione del codice, e la creazione di test \textit{ad hoc} per il sistema, traendo vantaggio dalle debolezze scoperte.
Questo approccio consente di valutare, in primo luogo, la leggibilità e la modularità del codice.
\end{solution}

\newpage
\begin{problem}{2.9}
Capacità di sopravvivenza del sistema
\end{problem}
\begin{solution}
La capacità di sopravvivenza del sistema indica la capacità di effettuare servizi agli utenti che ne hanno il permesso, qualora il sistema sia sotto attacco o nel caso in cui presenti componenti danneggiate.
Essa riguarda l'intero sistema e non le singole componenti, e risulta importante in quanto sia l'economia che la società dipendono da servizi digitali.
Nel processo di ingegnerizzazione dei processi sicuri occorre tenere conto della capacità di sopravvivenza, in quanto esistono servizi critici, soggetti ad attacchi.
Occorre quindi conoscere:
\begin{itemize}
	\item quali servizi risultano essere critici;
	\item in quali modi i servizi critici possono essere attaccati;
	\item lo standard di qualità minimo da mantenere nei servizi;
	\item come proteggere i servizi, qualora siano sotto attacco;
	\item come ripristinare il sistema nel tempo minore possibile, nel caso in cui i servizi siano sotto attacco.
\end{itemize}
Per potere ideare un sistema che supporti la capacità di sopravvivenza e per valutare le vulnerabilità di quest'ultimo è stato ideato il \textit{Survivable Analysis System}.
Questo metodo struttura la sopravvivenza di un sistema in un processo a quattro fasi e dipende dalle seguenti strategie complementari:
\begin{itemize}
	\item \textbf{Identificazione}: permette di individuare problemi grazie a un sistema che riconosce eventuali attacchi e fallimenti, valutandone il danno.
	\item \textbf{Resistenza}: permette al sistema di respingere attacchi.
	\item \textbf{Ripristino}: consente, nonostante i problemi del sistema, di garantire il funzionamento dei componenti essenziali, e di ripristinare tutti i servizi dopo un attacco.
\end{itemize}
Le fasi sono:
\begin{enumerate}
	\item \textbf{Capire il sistema}: esaminare l'architettura del sistema, i requisiti e gli obiettivi.
	\item \textbf{Identificare i servizi critici}: capire quali servizi sono critici, e quali sono le componenti che li gestiscono.
	\item \textbf{Simulare attacchi}: individuare i casi d'uso e gli scenari di eventuali attacchi e i componenti soggetti agli attacchi.
	\item \textbf{Analizzare la sopravvivenza}: identificare i componenti essenziali e vulnerabili, e sfruttare strategie di sopravvivenza come l'identificazione, la resistenza e il ripristino.
\end{enumerate}
Sfortunatamente l'analisi della sopravvivenza non viene effettuata nella maggior parte dei processi di ingegnerizzazione, in quanto molte aziende che non hanno subito attacchi risultano scettiche nell'investire sulla sicurezza.
È tuttavia consigliato quest'ultimo investimento, prevenendo eventuali attacchi, piuttosto che subirli, in quanto le perdite conseguenti risulterebbero gravi in termini di risorse e, nei casi peggiori, di vite.
\end{solution}
