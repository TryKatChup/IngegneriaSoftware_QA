%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amsthm,amssymb,amsfonts, fancyhdr, color, comment, graphicx, environ}
\usepackage{xcolor}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\usepackage{mdframed}
\usepackage{minted}
\usepackage[shortlabels]{enumitem}
\usepackage{indentfirst}
\usepackage{hyperref}
% Define emphasis
\DeclareTextFontCommand{\emph}{\bfseries\em}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=blue,
}

\pagestyle{fancy}
% Define problem environment
\newenvironment{problem}[2][Domanda]
    { \begin{mdframed}[backgroundcolor=gray!20] \textbf{#1 #2} \\}
    {  \end{mdframed}}

% Define solution environment
\newenvironment{solution}
    {\textit{Risposta:}}
    {}

\renewcommand{\qed}{\quad\qedsymbol}

% Prevent line break in inline mode
\binoppenalty=\maxdimen
\relpenalty=\maxdimen

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document information (author, course, date)
\lhead{Karina Chichifoi }
\rhead{\today}
\chead{\textbf{Ingegneria del software Q\&A}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Define huge title
\makeatletter
\newcommand\HUGE{\@setfontsize\Huge{30}{40}}
\makeatother
\begin{document}
% TITLEPAGE
\begin{titlepage}
	\centering
	\large
	A cura di Karina Chichifoi - Ultima revisione: \today

	\noindent\rule{15cm}{0.2pt}

	\vspace{1.5cm}

	\HUGE
	\textbf{Ingegneria del Software Q\&A}

	\vspace{17cm}

	\normalsize
	\url{https://github.com/TryKatChup/IngegneriaSoftware_QA}

	\clearpage
\end{titlepage}
% Premessa
\renewcommand{\abstractname}{}
\begin{abstract}
	\section*{Premessa}
	Ho scritto questo file in modo da facilitare lo studio e il superamento dell'esame di Ingegneria del Software.
	Tuttavia è consigliato integrare questo materiale con le slide del professore Marco Patella, disponibili sulla piattaforma \textit{Insegnamenti Online}.

	\section*{Contribuire alla guida}

	Se ritieni di poter migliorare la guida, oppure se sono state aggiunte altre domande al di fuori di questo file, o se hai trovato un errore, visita la repository GitHub ed apri una \textit{issue}, oppure inviami un messaggio. Ogni contributo è ben accetto :)

	\vspace{4mm}
	Link Repository: \url{https://github.com/TryKatChup/IngegneriaSoftware_QA}

	\vspace{5mm}

	\begin{figure}[htb!]
		\centering
		\includegraphics[width=4cm]{qrcode.png}
		\caption{QR Code alla repository di GitHub}
	\end{figure}
\end{abstract}
\newpage
\section{Modulo 1}
\begin{problem}{1.1}
Come viene implementata l'ereditarietà multipla?
\end{problem}
\begin{solution}
\end{solution}
\begin{problem}{1.2}
Si esegua una classificazione del polimorfismo secondo Cardelli-Wegner e si mostri l'implementazione del polimorfismo per inclusione.
\end{problem}
\begin{solution}
\end{solution}
\begin{problem}{1.3}
Procedimento di compilazione ed esecuzione del codice all'interno del framework .NET tramite il CLR.
\end{problem}
\begin{solution}
\end{solution}

\begin{problem}{1.4}
Tipi di dati in .NET
\end{problem}
\begin{solution}
\end{solution}


\begin{problem}{1.5}
Differenza tra tipi valore e tipi riferimento in .NET
\end{problem}
\begin{solution}
\end{solution}


\begin{problem}{1.6}
Garbage Collector in C\#
\end{problem}
\begin{solution}
\end{solution}


\begin{problem}{1.7}
Passaggio dei parametri in C\#
\end{problem}
\begin{solution}
\end{solution}




\begin{problem}{1.8}
Concetto di delegato in C\#
\end{problem}
\begin{solution}
\end{solution}


\begin{problem}{1.9}
Metaprogrammazione e riflessione in C\#
\end{problem}
\begin{solution}
\end{solution}


\begin{problem}{1.10}
Spiegare i quattro bad design (fragilità, immobilità, rigidità, viscosità)
\end{problem}
\begin{solution}
\end{solution}


\begin{problem}{1.11}
Principio di singola responsabilità con almeno un esempio
\end{problem}
\begin{solution}
\end{solution}


\begin{problem}{1.12}
Principio di inversione delle dipendenze con almeno un esempio
\end{problem}
\begin{solution}
\end{solution}


\begin{problem}{1.13}
Principio di segregazione delle interfacce con almeno un esempio
\end{problem}
\begin{solution}
\end{solution}


\begin{problem}{1.14}
Principio aperto/chiuso con almeno un esempio
\end{problem}
\begin{solution}
\end{solution}


\begin{problem}{1.15}
Principio di sostituibilità di Liskov con almeno un esempio
\end{problem}
\begin{solution}
\end{solution}


\begin{problem}{1.16}
Principi per l'architettura dei package
\end{problem}
\begin{solution}
\end{solution}


\begin{problem}{1.17}
Pattern Singleton con esempi
\end{problem}
\begin{solution}
\end{solution}


\begin{problem}{1.18}
Pattern Observer con esempi
\end{problem}
\begin{solution}
\end{solution}


\begin{problem}{1.19}
Pattern Strategy con esempi
\end{problem}
\begin{solution}
\end{solution}


\begin{problem}{1.20}
Pattern Adapter con esempi
\end{problem}
\begin{solution}
\end{solution}

\begin{problem}{1.21}
Pattern Decorator con esempi
\end{problem}
\begin{solution}
\end{solution}

\begin{problem}{1.22}
Pattern Composite con esempi
\end{problem}
\begin{solution}
\end{solution}

\begin{problem}{1.23}
Modello LMU nei VCS con vantaggi e svantaggi
\end{problem}
\begin{solution}
\end{solution}
\newpage
\section{Modulo 2}
\begin{problem}{2.1}
Spiegare il modello a cascata e le sue criticità.
\end{problem}
\begin{solution}
Il modello a cascata (waterfall model) è un modello di processo di sviluppo software che prevede fasi sequenziali distinte tra loro:
\begin{itemize}
	\item studio di fattibilità
	\item analisi dei requisiti
	\item analisi del problema
	\item progettazione
	\item implementazione
	\item collaudo
	\item manutenzione
\end{itemize}
Ciascuna fase di sviluppo deve essere svolta in maniera esaustiva, prima di passare alla successiva, in modo da non tornare più indietro.
Per questo modello è importante definire:
\begin{itemize}
	\item \textbf{semilavorati}: consistono in documentazione di tipo cartaceo, codice dei singoli moduli, sistema nel suo complesso.\newline
	Vengono prodotti alla fine di una fase, e utilizzati dalla fase successiva; in questo modo viene garantito un controllo della qualità del lavoro eseguito in ogni fase.
	\item \textbf{date}: stabiliscono una scadenza entro la quale devono essere prodotti i semilavorati, in modo da tracciare il progresso del lavoro (workflow).
\end{itemize}
L'efficacia del modello a cascata è determinata dai seguenti fattori:
\begin{itemize}
	\item \textbf{immutabilità dell'analisi}: i clienti sono in grado di esprimere tutte le loro richieste sin da subito, pertanto nella fase iniziale del progetto si possono definire tutte le funzionalità che il software deve eseguire
	\item \textbf{immutabilità del progetto}: progettare l'intero sistema prima di avere scritto codice risulta possibile
\end{itemize}
Un importante vantaggio di questo approccio risulta essere un maggiore controllo dell'andamento del progetto; tuttavia la rigidità di questo modello rappresenta un grosso svantaggio, in quanto:
\begin{itemize}
	\item Man mano che il sistema prende forma le sue specifiche cambiano in continuazione, così come la visione che i clienti hanno del sistema
	\item Spesso, per avere prestazioni migliori, occorre revisionare il progetto.
\end{itemize}
Per risolvere parzialmente i problemi sopra citati si è introdotto un modello a cascata con forme limitate di retroazione a un livello.
Una possibile soluzione al problema consiste nel realizzare un prototipo che, una volta terminato il compito, viene abbandonato (\textit{throw-away prototyping}); successivamente viene costruito il sistema reale rispettando il modello a cascata.
\newline
Quest'ultimo approccio risulta talmente dispensioso da eliminare i vantaggi economici del modello a cascata.
\end{solution}


\begin{problem}{2.2}
Spiegare il modello a cascata e il modello iterativo
\end{problem}
\begin{solution}
Per il modello a cascata si veda la domanda 2.1.
\newline
Il modello iterativo prevede un numero elevato di passi nel ciclo di sviluppo che iteramente aumentano il livello di dettaglio del sistema.
Uno svantaggio di questo modello è che non può essere utilizzato nella realizzazione dei progetti significativi.
Un esempio di processo di sviluppo che utilizza il modello iterativo è \textit{Rational Unified Process} (RUP).
\end{solution}


\begin{problem}{2.3}
Illustrare RUP
\end{problem}
\begin{solution}
Il \textit{Rational Unified Process} (RUP) rappresenta un modello di processo software \textbf{iterativo} (si veda domanda 2.2) e \textbf{ibrido} (contiene elementi di tutti i modelli di processo generici) pensato per software di grandi dimensioni.
\newline
Esistono tre aspetti importanti del processo di sviluppo:
\begin{itemize}
	\item \textbf{Prospettiva dinamica}: mostra l'evoluzione del modello nel tempo. È composta da 4 fasi:
	\begin{enumerate}
		\item \textbf{Avvio}: lo scopo di questa fase è di delineare il \textit{business case}, ovvero comprendere il tipo di mercato a cui si rivolge, le entità esterne (persone e sistemi) che interagiscono con il sistema.
		\newline
		Durante la fase di avvio si utilizzano modelli di caso d'uso e si effettua una valutazione dei rischi.
		\item \textbf{Elaborazione}: questa fase definisce la struttura complessiva del sistema; comprende l'analisi del dominio e una prima fase di progettazione dell'architettura.
		\newline
		Occorre soddisfase alcuni criteri, tra i quali:
		\begin{itemize}
			\item Modello dei casi d'uso completo all' 80\%
			\item Descrizione dell'architettura del sistema
			\item Sviluppo dell'architettura del sistema
			\item Sviluppo di un'architettura eseguibile adatta agli use case significativi
			\item Revisione dei business case e dei rischi
			\item Pianificazione del progetto complessivo
		\end{itemize}
		\textbf{Nota bene:} al termine di questa fase modificare il progetto risulterà più difficile e dannoso.
		\item \textbf{Costruzione}: durante questa fase avviene la progettazione, la programmazione e il collaudo del sistema.
		Lo sviluppo delle diverse parti del sistema avviene in parallelo; successivamente vengono integrate.
		\newline
		Al termine di questa fase il sistema software dovrebbe essere funzionante e la relativa documentazione dovrebbe risultare pronta.
		\item \textbf{Transizione}: il sistema passa dall'ambiente di sviluppo a quello dell'utente finale. Quest'ultimo viene istruito nell'utilizzo del sistema, e si effettua \textit{beta testing} del sistema a scopo di verifica e validazione.
	\end{enumerate}
	\item \textbf{Prospettiva statica}: si focalizza sulle attività di produzione del software, note come \textit{workflow}; la descrizione di questi ultimi è orientata ai modelli associati a UML.
	Esistono sei workflow principali:
	\begin{enumerate}
		\item \textbf{Modellazione delle attività aziendali}: i processi aziendali vengono modellati, sfruttando il \textit{business case}
		\item \textbf{Requisiti}: vengono sviluppati i casi d'uso per la stesura dei requisiti; avviene l'identificazione degli attori che interagiscono con il sistema
		\item \textbf{Analisi e progetto}: attraverso l'utilizzo dei modelli architetturali e sequenziali degli oggetti e delle componenti viene creato e documentato un \textit{modello di progetto}
		\item \textbf{Implementazione}: i componenti vengono implementati; grazie alla generazione automatica del codice a partire dai modelli precedentemente definiti
		\item \textbf{Test}: vengono testati i sottocomponenti e il sistema finale
		\item \textbf{Rilascio}: il prodotto viene distribuito agli utenti
	\end{enumerate}
	Oltre ai 6 workflow principali vengono definiti 3 workflow di supporto:
	\begin{enumerate}
		\item \textbf{Gestione della configurazione e delle modifiche}: gestisce i cambiamenti del sistema
		\item \textbf{Gestione del progetto}: gestisce lo sviluppo del sistema
		\item \textbf{Ambiente}: fornisce agli sviluppatori degli strumenti adeguati
	\end{enumerate}
	\item \textbf{Prospettiva pratica}: suggerisce le \textit{buone prassi} da seguire nello sviluppo dei sistemi.
	\newline
	Esistono sei fasi fondamentali:
	\begin{enumerate}
		\item \textbf{Sviluppare ciclicamente il software}: pianificare (??) e consegnare le funzioni aventi la priorità più alta
		\item \textbf{Gestire i requisiti}: documentare ogni richiesta esplicita del cliente e ogni cambiamento effettuato, analizzandone l'impatto
		\item \textbf{Usare architetture basate sui componenti}: strutturare l'architettura del sistema in più componenti
		\item \textbf{Usare modelli visivi del software}: utilizzare grafici UML per la rappresentazione statica e dinamica del software
		\item \textbf{Verificare la qualità del software}: assicurarsi che vengano raggiunti gli standard di qualità previsti dall'organizzazione
		\item \textbf{Controllare le modifiche del software}: utilizzare strumenti e pratiche che permettono di gestire modifiche al software
	\end{enumerate}
\end{itemize}

\end{solution}

\begin{problem}{2.4}
Tipologie di analisi dei requisiti (in particolare quelli della sicurezza)
\end{problem}
\begin{solution}
\end{solution}

\begin{problem}{2.5}
Si illustri brevemente il ciclo di vita della valutazione del rischio
\end{problem}
\begin{solution}
\end{solution}

\begin{problem}{2.6}
Principali categorie di requisiti per la sicurezza
\end{problem}
\begin{solution}
\end{solution}


\begin{problem}{2.7}
Commentare eventuali errori di un diagramma UML
\end{problem}
\begin{solution}
\end{solution}


\begin{problem}{2.8}
Linee guida di progettazione nella sicurezza
\end{problem}
\begin{solution}
\end{solution}

\begin{problem}{2.9}
White box e black box testing
\end{problem}
\begin{solution}
\end{solution}

\begin{problem}{2.10}
Capacità di sopravvivenza del sistema
\end{problem}
\begin{solution}
\end{solution}
\end{document}
